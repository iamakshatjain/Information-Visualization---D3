<!DOCTYPE html>
<html>
    <head>
        <title>D3</title>
        <script type="text/javascript" src="https://d3js.org/d3.v6.min.js"></script>
    </head>
    <body>
        <svg width="100%" height="17000" id="#container">
            <g id="graph"></g>
            <g id="cities"></g>
        </svg>
    </body>
    <script>
        d3.csv('smart-cities.csv').then(showData);
        const container = d3.select('#container');
        function raiseContainerHeight(height){
            const svgHeight = container.attr('scrollHeight');
            container.attr('scrollHeight', svgHeight + 500);
        }

        function showData(data) {            // transforming data
            const stateToFunds = {};
            for(let city of data){
                const state = city['State/UT'];
                const funds = +city['Total Central Release'];
                const utilisedFunds = +city['Utilisation of GOI Funds'];
                const cityName = city['Name of City'];
                const funds2015 = +city['During 2015-16'];
                const funds2016 = +city['During 2016-17'];
                const funds2017 = +city['During 2017-18'];
                const funds2018 = +city['During 2018-19'];
                if(state !== 'Total')
                {
                    if(state in stateToFunds){
                        stateToFunds[state]['availableFunds'] += funds;
                        stateToFunds[state]['utilisedFunds'] += utilisedFunds;
                        stateToFunds[state]['fundsPerYear'][0] += funds2015;
                        stateToFunds[state]['fundsPerYear'][1] += funds2016;
                        stateToFunds[state]['fundsPerYear'][2] += funds2017;
                        stateToFunds[state]['fundsPerYear'][3] += funds2018;

                    } else {
                        stateToFunds[state] = {}
                        stateToFunds[state]['availableFunds'] = funds;
                        stateToFunds[state]['utilisedFunds'] = utilisedFunds;
                        stateToFunds[state]['cities'] = [];
                        stateToFunds[state]['fundsPerYear'] = [0, 0, 0, 0];
                    }
                    stateToFunds[state]['cities'].push({city:cityName, availableFunds: funds-utilisedFunds, utilisedFunds: utilisedFunds});
                }
            } 

            var stateToFundsArray = Object.keys(stateToFunds).map(key => ({state: key, ...stateToFunds[key]}));
            stateToFundsArray.forEach(state => state.availableFunds-=state.utilisedFunds);
            stateToFundsArray.sort((a, b) =>  (b.availableFunds+b.utilisedFunds) - (a.availableFunds+a.utilisedFunds));
            console.log(stateToFundsArray);

            // creating stacked data
            const subgroups = ['utilisedFunds', 'availableFunds'];
            const stackedData = d3.stack().keys(subgroups)(stateToFundsArray);
            var color = d3.scaleOrdinal()
                .domain(subgroups)
                .range(['#e41a1c','#4daf4a']);

            // scalling
            const min = d3.min(stateToFundsArray, d => +d.availableFunds+d.utilisedFunds);
            const median = d3.median(stateToFundsArray, d => +d.availableFunds+d.utilisedFunds);
            const max = d3.max(stateToFundsArray, d => +d.availableFunds+d.utilisedFunds);

            const height = 500;
            const width = 500;
            const sideShift = 150;

            // scalling
            const widthScale = d3.scaleLinear().domain([0, max]).range([0, width]);
            const cityScale = d3.scaleBand().domain(stateToFundsArray.map(d => d.state)).range([0, height]).padding(0.2);
            
            // binding the data
            const drawSpace = d3.select('#graph').selectAll('g').data(stackedData);
            drawSpace.enter().append("g")
                .attr("fill", d => color(d.key))
            .selectAll('rect')
            .data(d => d)
            .enter()
            .append('rect')
                .attr('width', d => widthScale(d[1] - d[0]))
                .attr("height", cityScale.bandwidth())
                .attr('x', d => sideShift + widthScale(d[0]))
                .attr('y', d => cityScale(d.data.state));
            
            // axis
            const xAxis = d3.select('#graph').append('g');
            const yAxis = d3.select('#graph').append('g');
            const axisB = d3.axisBottom(widthScale)
                            .ticks(5);
            const axisL = d3.axisLeft(cityScale).ticks(5);
            xAxis.call(axisB)
                .style('transform', 'translate(' + sideShift + 'px,' + height + 'px)');
            yAxis.call(axisL)
                .style('transform', 'translate(' + sideShift + 'px,0px)');
                
            // display city data
            for(let i=0; i<stateToFundsArray.length; i++)
                displayCity(stateToFundsArray[i], stateToFundsArray[i].state, height + 200, i);
        }

        function displayCity(data, state, verticalMovementOffset, index){
            const fundsPerYear = data.fundsPerYear;
            const citiesData = data.cities;

            // sorting based on funds
            citiesData.sort((a, b) =>  (b.availableFunds+b.utilisedFunds) - (a.availableFunds+a.utilisedFunds));
            
            // scalling
            const min = d3.min(citiesData, d => +d.availableFunds+d.utilisedFunds);
            const median = d3.median(citiesData, d => +d.availableFunds+d.utilisedFunds);
            const max = d3.max(citiesData, d => +d.availableFunds+d.utilisedFunds);

            // creating stacked data
            const subgroups = ['utilisedFunds', 'availableFunds'];
            const stackedData = d3.stack().keys(subgroups)(citiesData);
            var color = d3.scaleOrdinal()
                .domain(subgroups)
                .range(['#e41a1c','#4daf4a']);

            const height = 300;
            const width = 500;
            const sideShift = 50;

            // scalling
            const barHeightScale = d3.scaleLinear().domain([0, max]).range([height, 0]);
            const cityScale = d3.scaleBand().domain(citiesData.map(d => d.city)).range([0, width]).padding(0.2);
            const colorScale = d3.scaleLinear().domain([min, median, max]).range(['yellow', 'orange', 'red']);
            
            // binding the citiesData
            const drawSpace = d3.select('#graph').append('g').attr('id', state).style('transform', `translate(0px, ${verticalMovementOffset + (index)*1.5*height}px)`);
            drawSpace.append('text').text(state).attr('y', '-20px').style('font', 'bold 40px Sans-serif');

            drawSpace.append('g').selectAll('rect').data(stackedData).enter().append("g")
                .attr("fill", d => color(d.key))
            .selectAll('rect')
            .data(d => d)
            .enter()
            .append('rect')
                .attr('width', cityScale.bandwidth())
                .attr("height", d => barHeightScale(d[0]) - barHeightScale(d[1]))
                .attr('x', d => cityScale(d.data.city) + sideShift)
                .attr('y', d => barHeightScale(d[1]));
            
            // axis
            const xAxis = drawSpace.append('g');
            const yAxis = drawSpace.append('g');
            const axisB = d3.axisBottom(cityScale);
            const axisL = d3.axisLeft(barHeightScale).ticks(5);
            xAxis.call(axisB)
                .style('transform', 'translate(' + sideShift + 'px,' + height + 'px)');
            yAxis.call(axisL)
                .style('transform', 'translate(' + sideShift + 'px,0px)');
        }
    </script>
</html>